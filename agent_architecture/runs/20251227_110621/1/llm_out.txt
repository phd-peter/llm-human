<THOUGHTS>
*   The problem asks for the maximum XOR of two substrings of a binary string $S$ of length $N \le 10^7$.
*   Let $s_1$ be the longest substring starting with '1' (the suffix of $S$ starting from the first '1'). This $s_1$ will have the maximum possible number of bits $L$.
*   To maximize $f(s_1) \oplus f(s_2)$, we pick $s_2$ such that the XOR result is as large as possible.
*   If $s_1$ consists of all '1's, the max XOR is $f(s_1) \oplus 1 = f(11...10)$.
*   If $s_1$ has a '0' at some index $j$, we want to pick $s_2$ of length $L-j$ starting with '1' to flip that '0' to '1'.
*   The set of candidate starting positions $k$ for $s_2$ can be large, but we only need a few candidates because in periodic strings they are redundant, and in random strings the candidates shrink quickly.
*   The bit-by-bit filtering of candidates can be optimized by using a threshold and Python's efficient string/integer operations.
*   Python's `int(s, 2)` and `bin(n)` are $O(N)$, which is crucial for handling $N=10^7$.
</THOUGHTS>

<PLAN>
1.  Find the first '1' in $S$. If none, output '0'.
2.  Let $s_1 = S[first\_1:]$ and $L = len(s_1)$.
3.  Find the first '0' in $s_1$ at index $j$.
4.  If no '0' exists, output $f(s_1) \oplus 1$ in binary (or '0' if $L=1$ and no '0' in $S$).
5.  If '0' exists at $j$, find all $k$ such that $S[k] = '1'$ and $k + (L-j) \le N$.
6.  Limit the number of candidates $k$ to a reasonable threshold (e.g., 1000) to ensure $O(N \cdot threshold)$ complexity.
7.  Filter the candidates bit-by-bit to maximize the XOR with $s_1[j:]$.
8.  Calculate the final XOR using Python's `int` and output with `bin()`.
</PLAN>

<CODE>
import sys

# Increase the limit for integer-string conversions for binary
# Note: int(s, 2) and bin(n) are actually O(N) and not affected by the
# str-int limit usually, but we set it just in case for safety.
sys.set_int_max_str_digits(10000005)

def solve():
    # Read all input at once for speed
    try:
        data = sys.stdin.read().split()
    except EOFError:
        return
    if not data:
        return
    
    T = int(data[0])
    idx = 1
    
    for _ in range(T):
        if idx >= len(data):
            break
        N = int(data[idx])
        S = data[idx+1]
        idx += 2
        
        # 1. Find the first '1'
        first_1 = S.find('1')
        if first_1 == -1:
            sys.stdout.write('0\n')
            continue
        
        # s1 is the longest substring starting with 1
        s1_str = S[first_1:]
        L = len(s1_str)
        
        # 2. Find the first '0' in s1
        j = s1_str.find('0')
        if j == -1:
            if L == 1:
                # S could be "1", "01", "001", etc.
                sys.stdout.write('1\n' if '0' in S else '0\n')
            else:
                # s1 is 11...1, max XOR is 11...10
                sys.stdout.write('1' * (L - 1) + '0\n')
            continue
        
        # 3. Optimize s2 search
        # s2 must have length L-j to flip the '0' at s1[j].
        len_s2 = L - j
        
        # Find all k such that S[k] == '1' and k + len_s2 <= N
        # Thresholding to 1000 candidates is safe for O(N) complexity.
        K = []
        max_k = N - len_s2
        for k in range(max_k + 1):
            if S[k] == '1':
                K.append(k)
                if len(K) >= 1000:
                    break
        
        if not K:
            # Should not happen as s1 exists
            sys.stdout.write(s1_str + '\n')
            continue
            
        # 4. Bit-by-bit filtering to find the best s2 starting position
        for bit in range(1, len_s2):
            # To maximize XOR, we want the resulting bit to be '1'.
            # Result bit is s1[j+bit] ^ s2[bit].
            # So target s2[bit] is NOT(s1[j+bit]).
            target = '1' if s1_str[j + bit] == '0' else '0'
            
            K_target = [k for k in K if S[k + bit] == target]
            if K_target:
                K = K_target
        
        # 5. Calculate and print the result
        k_best = K[0]
        s2_str = S[k_best : k_best + len_s2]
        
        v1 = int(s1_str, 2)
        v2 = int(s2_str, 2)
        
        # bin() result starts with '0b', remove it
        sys.stdout.write(bin(v1 ^ v2)[2:] + '\n')

if __name__ == '__main__':
    solve()

</CODE>

<STDIN>
4
3
010
5
10101
5
00100
5
11111
4
2
00
2
01
2
10
2
11
</STDIN>

<STATE_UPDATE>
- Current Approach: Bit-by-bit filtering with a candidate threshold and Python's efficient big integers.
- Next Objective: Finished
</STATE_UPDATE>

[EVALUATION PHASE]
<ANALYSIS>
1.  **Code Execution Analysis:**
    *   The provided code for Example 1 was executed and produced the correct outputs.
    *   The algorithmic approach focuses on finding the longest possible substring $s_1$ starting with '1' and then finding an optimal $s_2$ that maximizes the XOR result by flipping the first '0' in $s_1$.

2.  **Complexity and Efficiency:**
    *   The constraints are $N \le 10^7$ and $T \le 100$, with $\sum N \le 10^7$ across all test cases. The time limit is 2.0 seconds.
    *   The current approach has a risk of $O(N^2)$ in specifically engineered worst-case scenarios (where the number of candidates $|K|$ stays large and multiple "choices" are made or many identical bits are checked).
    *   However, by optimizing the bit-by-bit filtering logic to only rebuild $K$ when it strictly shrinks, the total time complexity becomes $O(N)$ for almost all strings and $O(N + \sum |K|_{choice})$ overall. Given that $\sum N \le 10^7$, an efficient $O(N)$ Python implementation should pass within 2 seconds.

3.  **Correctness:**
    *   The strategy of $s_1 = S[first\_1:N]$ is sound because any shorter $s_1$ would result in a shorter binary value, and $s_1$ is already the longest possible starting with '1'.
    *   The search for $s_2$ aims to maximize the XOR by matching the bit-complement of $s_1$ after the first '0'.
    *   Corner cases such as all '1's, all '0's, leading zeros, and short strings have been analyzed and handled.

4.  **Final Polish:**
    *   Using `sys.stdin.read().split()` and `sys.stdout.write` for fast I/O.
    *   Using Python's built-in `int(s, 2)` and `bin(n)` which are efficient $O(N)$ operations for binary strings.

</ANALYSIS>

<STATE_UPDATE>

- Current Approach: Finding longest $s_1$ starting with '1', then greedy bit-by-bit filtering for $s_2$ to maximize XOR result.
- Status: Finished
- Next Objective: None
</STATE_UPDATE>

```python
import sys

# The problem asks for the maximum XOR of two substrings s1 and s2 of a binary string S.
# To maximize XOR, we should make the resulting binary string as long as possible
# and have as many leading ones as possible.

def solve():
    # Fast I/O
    try:
        input_data = sys.stdin.read().split()
    except EOFError:
        return
    if not input_data:
        return
    
    T = int(input_data[0])
    ptr = 1
    
    output = []
    for _ in range(T):
        if ptr >= len(input_data):
            break
        N = int(input_data[ptr])
        S = input_data[ptr+1]
        ptr += 2
        
        # 1. Find the first '1'. The longest substring starting with '1' is s1 = S[first_1:N].
        # Any other substring starting with '1' will be shorter or equal in length.
        # Since we want to maximize the XOR, having the most significant bit at the
        # highest possible position (N - first_1 - 1) is priority.
        first_1 = S.find('1')
        if first_1 == -1:
            output.append('0')
            continue
        
        # 2. Find the first '0' in s1 (relative to first_1). 
        # The result of s1 ^ s2 will have '1's for all bits before the first '0' of s1,
        # provided s2 is shorter than s1.
        first_0 = S.find('0', first_1)
        if first_0 == -1:
            # s1 is entirely composed of '1's.
            L = N - first_1
            # If there's any '0' in S, we can XOR s1 with '0' (substring) to get all '1's.
            if S.find('0') != -1:
                output.append('1' * L)
            else:
                # S is all '1's. Substrings are 1, 11, 111, ...
                # Max XOR of two such substrings is (e.g.) 11...11 ^ 1 = 11...10.
                if L == 1:
                    output.append('0')
                else:
                    output.append('1' * (L - 1) + '0')
            continue
        
        # 3. Optimize s2. s2 must flip the '0' at index first_0. 
        # This means s2 must have a '1' at that position and be of appropriate length.
        # Let s1 = S[first_1 : N]. Length L = N - first_1.
        # Let the first '0' be at s1[j]. j = first_0 - first_1.
        # To flip s1[j], s2 must have length L-j and start with '1'.
        # s2 = S[k : k + (L-j)] where S[k] == '1'.
        # Since s2 must start at or before first_0 to be of length L-j, k <= first_0.
        j = first_0 - first_1
        L = N - first_1
        
        # Candidates for starting position of s2:
        K = [k for k in range(first_0 + 1) if S[k] == '1']
        
        # 4. Greedy filtering for the best s2 starting position.
        # We want to match the complement of s1[j+1:] bit by bit.
        for bit in range(1, L - j):
            target = '1' if S[first_0 + bit] == '0' else '0'
            
            # Check if any candidate has the target bit at this position.
            has_target = False
            all_same = True
            first_bit = S[K[0] + bit]
            
            # Efficiently determine if we have a choice (some match target, some don't).
            # If all candidates provide the same bit, K doesn't change.
            for k in K:
                if S[k + bit] == target:
                    has_target = True
                if S[k + bit] != first_bit:
                    all_same = False
                if has_target and not all_same:
                    break
            
            if not all_same:
                # We only rebuild the list if it will actually shrink.
                # Since we found a choice, target must exist among candidates.
                K = [k for k in K if S[k + bit] == target]
                if len(K) == 1:
                    break
        
        # 5. Calculate final result using best candidate.
        k_best = K[0]
        v1_val = int(S[first_1 : N], 2)
        v2_val = int(S[k_best : k_best + (L - j)], 2)
        
        # bin() returns '0b...', we strip it.
        output.append(bin(v1_val ^ v2_val)[2:])
    
    sys.stdout.write('\n'.join(output) + '\n')

if __name__ == '__main__':
    solve()

```