<THOUGHTS>
The current approach uses coordinate compression and a Fenwick tree (Binary Indexed Tree) to efficiently find the maximum $A[i]$ such that $A[i] \le K - A[j]$ for a given $j$, subject to the constraints $i < j$ and $|i - j| \ge D$.

1.  **Coordinate Compression**: Since $A[i]$ values can be large or negative, we map the unique values of $A$ to their ranks (1 to $M$, where $M \le N$). This allows us to use them as indices in the BIT.
2.  **Constraint Handling**: The conditions $i < j$ and $|i - j| \ge D$ combine to $i \le j - \max(1, D)$. Let $D_{eff} = \max(1, D)$. As we iterate $j$ from $D_{eff}$ to $N-1$, we add $A[j - D_{eff}]$ to the BIT. This ensures that when we query for a given $j$, the BIT contains only values $A[i]$ for valid $i$.
3.  **Prefix Maximum BIT**: The BIT is designed to store and query prefix maximums. `update(rank, value)` updates the BIT with a value at its rank, and `query(rank)` returns the maximum value stored at any rank less than or equal to the query rank.
4.  **Efficiency**: The approach runs in $O(N \log N)$ time and $O(N)$ space, which is optimal for $N = 200,000$.
5.  **Edge Cases**: The logic handles cases where $D=0$ (treated as $D=1$ because $i < j$), negative values of $A[i]$ and $K$, and cases where no valid pair exists (returning -1).

The evidence shows that previous implementations were successful on provided test cases. This final implementation consolidates the logic into a robust and efficient version.
</THOUGHTS>

<PLAN>
1. Define a function `find_max_sum(N, A, K, D)`.
2. Handle base cases where $N < 2$ or the index constraint $D_{eff} \ge N$ is impossible.
3. Perform coordinate compression on the unique values of $A$.
4. Implement a BIT that supports prefix maximum updates and queries.
5. Iterate $j$ from $D_{eff}$ to $N-1$:
    - Update the BIT with the value $A[j - D_{eff}]$.
    - Calculate the target value $T = K - A[j]$.
    - Find the rank of the largest element in the compressed array $\le T$ using `bisect_right`.
    - If a valid rank exists, query the BIT for the maximum $A[i]$.
    - Update the global maximum sum.
6. Return the final maximum sum or -1.
</PLAN>

<CODE>
import bisect

def find_max_sum(N, A, K, D):
    # Constraint: i < j and j - i >= D implies i <= j - max(1, D)
    deff = max(1, D)
    
    if N < 2 or deff >= N:
        return -1
    
    # Coordinate Compression for BIT indices
    unique_vals = sorted(list(set(A)))
    rank_map = {val: i + 1 for i, val in enumerate(unique_vals)}
    m = len(unique_vals)
    
    # Binary Indexed Tree for prefix maximum
    # Initialized with negative infinity to handle negative A[i]
    NEG_INF = -float('inf')
    bit = [NEG_INF] * (m + 1)
    
    def update(idx, val):
        """Standard BIT update for prefix maximum."""
        while idx <= m:
            if val > bit[idx]:
                bit[idx] = val
                idx += idx & (-idx)
            else:
                # If the current bit[idx] is already >= val, 
                # all ancestors are also already >= val.
                break
            
    def query(idx):
        """Standard BIT query for prefix maximum in range [1, idx]."""
        res = NEG_INF
        while idx > 0:
            if bit[idx] > res:
                res = bit[idx]
            idx -= idx & (-idx)
        return res
    
    max_total_sum = NEG_INF
    
    # Process the array
    for j in range(deff, N):
        # Maintain indices i such that i <= j - deff
        # Add A[j - deff] to the BIT
        val_to_add = A[j - deff]
        update(rank_map[val_to_add], val_to_add)
        
        # We need max A[i] such that A[i] <= K - A[j]
        target_val = K - A[j]
        # Use binary search on unique_vals to find the maximum possible rank
        idx = bisect.bisect_right(unique_vals, target_val)
        
        if idx > 0:
            best_ai = query(idx)
            if best_ai != NEG_INF:
                current_sum = best_ai + A[j]
                if current_sum > max_total_sum:
                    max_total_sum = current_sum
                    
    return int(max_total_sum) if max_total_sum != NEG_INF else -1

# Verification with example
if __name__ == "__main__":
    # Test example
    N_ex, A_ex, K_ex, D_ex = 5, [5, 1, 3, 4, 2], 6, 2
    print(find_max_sum(N_ex, A_ex, K_ex, D_ex))
</CODE>

<STATE_UPDATE>
- Current Approach: Coordinate Compression + BIT (Fenwick Tree) for prefix maximum
- Status: Successfully implemented and verified. Final code handles O(N log N) complexity and edge cases including negative values and D=0.
- Next Objective: Solution finalized.
</STATE_UPDATE>