<THOUGHTS>
The current approach uses coordinate compression combined with a Fenwick tree (Binary Indexed Tree) to maintain the prefix maximum of values $A[i]$ that satisfy the index constraint $i \le j - \max(1, D)$. For each $j$, we query the BIT for the maximum $A[i]$ such that $A[i] \le K - A[j]$. The time complexity is $O(N \log N)$ and space complexity is $O(N)$, which is efficient for $N = 200,000$. The evidence shows that the approach has passed various test cases including edge cases like $D=0$, negative numbers, and impossible scenarios. I will provide the final implementation.
</THOUGHTS>

<PLAN>
1. Implement the coordinate compression to map values of $A$ to ranks.
2. Implement a Fenwick Tree (BIT) to store the maximum value in a prefix of ranks.
3. Iterate through the array $A$ with index $j$, maintaining the valid range $[0, j - \max(1, D)]$ for index $i$.
4. For each $j$, query the BIT for the maximum $A[i]$ where $A[i] \le K - A[j]$ using `bisect_right`.
5. Update the overall maximum sum.
6. Return the maximum sum or -1 if no valid pair is found.
</PLAN>

<CODE>
import sys
from bisect import bisect_right

def solve(N, A, K, D):
    """
    Finds the maximum value of A[i] + A[j] such that:
    - i < j
    - A[i] + A[j] <= K
    - |i - j| >= D
    """
    if N < 2:
        return -1
    
    # Coordinate compression
    coords = sorted(list(set(A)))
    rank_map = {val: i + 1 for i, val in enumerate(coords)}
    num_coords = len(coords)
    
    # BIT to store prefix maximums
    # Initialize with a very small integer
    INF = 10**18
    bit = [-INF] * (num_coords + 1)
    
    def update(rank, val):
        while rank <= num_coords:
            if val > bit[rank]:
                bit[rank] = val
            rank += rank & -rank
            
    def query(rank):
        res = -INF
        while rank > 0:
            if bit[rank] > res:
                res = bit[rank]
            rank -= rank & -rank
        return res

    ans = -INF
    # The conditions i < j and |i - j| >= D imply i <= j - D.
    # Also, i < j must always hold. So i <= j - max(1, D).
    eff_D = max(1, D)
    
    for j in range(N):
        # Elements at index i = j - eff_D become valid for the current and future j
        if j >= eff_D:
            prev_val = A[j - eff_D]
            update(rank_map[prev_val], prev_val)
        
        # We need A[i] <= K - A[j]. Find the largest rank r such that coords[r-1] <= K - A[j]
        limit = K - A[j]
        r = bisect_right(coords, limit)
        if r > 0:
            max_ai = query(r)
            if max_ai > -INF // 2:
                current_sum = max_ai + A[j]
                if current_sum > ans:
                    ans = current_sum
                    
    return int(ans) if ans > -INF // 2 else -1

# Verification with example
if __name__ == "__main__":
    # Example 1
    print(f"Example result: {solve(5, [5, 1, 3, 4, 2], 6, 2)}")
    
    # Test D=0
    print(f"Test D=0: {solve(5, [5, 1, 3, 4, 2], 6, 0)}")
    
    # Test all negative
    print(f"Test all neg: {solve(5, [-5, -1, -3, -4, -2], -6, 2)}")
    
    # Test impossible
    print(f"Test impossible: {solve(5, [10, 20, 30, 40, 50], 5, 1)}")

    # Test case 4 from evidence
    print(f"Test Case 4: {solve(5, [5, 1, 3, 4, 2], 10, 1)}")
</CODE>

<STATE_UPDATE>
- Current Approach: Coordinate Compression + BIT (Fenwick Tree) for prefix maximum
- Status: Successfully implemented and verified with example cases and edge cases. 
- Next Objective: Solution finalized.
</STATE_UPDATE>