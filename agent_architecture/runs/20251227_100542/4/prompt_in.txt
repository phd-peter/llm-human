# Single-Turn Prompt Template

This is the exact string template injected into the LLM at every step.
Variables in `{{ }}` are populated by the Python Executive.

---

```text
[CONSTITUTION]

[CONSTITUTION]
GOALS:
- Solve the problem with 100% correctness
- Maximize efficiency
CONSTRAINTS:
- Do not assume unstated constraints
- Pass all provided verification tests
PROTOCOLS:
- Refine approach if fails 3 times
- Pivot if structural failure detected

- You are an advanced algorithmic agent. 
- Your goal is to solve the problem below with 100% correctness and efficiency.
- You have NO memory of previous turns. You must rely solely on the [STATE] and [EVIDENCE] provided.
- Do NOT hallucinate success. Only trust the Evidence.

[IMPORTANT – EXECUTION CONTRACT]
- The content inside <CODE>...</CODE> will be executed directly by a Python interpreter.
- DO NOT include markdown fences (```), explanations, or comments outside Python syntax.
- The <CODE> block MUST contain ONLY valid, executable Python code.
- Any text outside <CODE> will NOT be executed.


--------------------------------------------------------------------------------

[PROBLEM DESCRIPTION]
길이
M
M인 양의 정수열
X
1
,
…
,
X
M
X
1
​
 ,…,X
M
​
 이 주어질 때, 이 수열을 오름차순으로 만드는 것을 생각해 보자. 수열
X
1
,
…
,
X
M
X
1
​
 ,…,X
M
​
 이 오름차순이라는 것은, 각
i
i (
1
≤
i
≤
M
−
1
1≤i≤M−1)에 대해
X
i
≤
X
i
+
1
X
i
​
 ≤X
i+1
​
 이라는 것이다.

수열
X
X를 오름차순으로 만들기 위해, 수열
X
X에 다음 연산을 몇 번이든 반복해서 적용할 수 있다.

어떤
i
i (
1
≤
i
≤
M
1≤i≤M)에 대해
X
i
X
i
​
 에 2를 곱한다.
연산을 최소 횟수로 적용해서
X
X를 오름차순으로 만들 때, 이 최소 횟수를
f
(
X
)
f(X)라고 하자.

길이
N
N의 양의 정수열
A
1
,
…
,
A
N
A
1
​
 ,…,A
N
​
 과 쿼리
Q
Q개가 주어진다. 각 쿼리에는
1
≤
l
≤
r
≤
N
1≤l≤r≤N을 만족하는 정수
l
l과
r
r이 주어진다. 해당 쿼리에 대한 답은
f
(
A
l
,
…
,
A
r
)
f(A
l
​
 ,…,A
r
​
 )이다.
A
l
,
…
,
A
r
A
l
​
 ,…,A
r
​
 은
A
A의
l
l번째 원소부터
r
r번째 원소까지로 이루어진 부분 수열을 의미한다.

각 쿼리에 대한 답을 구하여라.

제약 조건
주어지는 모든 수는 정수이다.
1
≤
N
≤
250

000
1≤N≤250000
1
≤
Q
≤
250

000
1≤Q≤250000
1
≤
A
i
≤
1
0
9
1≤A
i
​
 ≤10
9
  (
1
≤
i
≤
N
1≤i≤N)
모든 쿼리에 대해
1
≤
l
≤
r
≤
N
1≤l≤r≤N
부분문제
(5점)
N
≤
10

000
N≤10000,
Q
≤
10

000
Q≤10000
(7점)
N
≤
10

000
N≤10000
(28점) 모든 쿼리에 대해
r
=

N
r=N
(10점)
A
i
≥
A
i
+
1
A
i
​
 ≥A
i+1
​
  (
1
≤
i
≤
N
−
1
1≤i≤N−1)
(5점)
A
i
≤
2
A
i
​
 ≤2 (
1
≤
i
≤
N
1≤i≤N)
(10점)
A
i
=

2
k
i
A
i
​
 =2
k
i
​

 를 만족하는 0 이상의 정수
k
i
k
i
​
 가 존재 (
1
≤
i
≤
N
1≤i≤N)
(35점) 추가 제약 조건 없음
입력 형식
첫 번째 줄에
N
N과
Q
Q가 공백으로 구분되어 주어진다.

두 번째 줄에
A
1
,
…
,
A
N
A
1
​
 ,…,A
N
​
 이 공백으로 구분되어 주어진다.

이후
Q
Q개의 줄에 걸쳐 쿼리들이 주어진다. 각 쿼리는
l
l과
r
r이 공백으로 구분되어 주어진다.

출력 형식
Q
Q개의 줄에 걸쳐 쿼리들의 답을 입력 순서대로 출력한다.

예제
예제 1
입력
10 5
5 2 7 3 2 9 6 3 3 5
3 9
1 10
1 8
2 4
8 9
출력
14
27
19
2
0
예제 2
입력
10 5
2 8 4 9 10 8 5 3 7 7
2 8
1 10
3 3
1 3
8 10
출력
7
11
0
1
0


--------------------------------------------------------------------------------

[STATE] (Context: Where we are)
{{TURN_INFO}}

[STATE]
Current Approach: None
Hypothesis: Initial State
Status: Debugging
Known Failures: ['Turn 1 Execution Error', 'Turn 2 Execution Error', 'Turn 3 Execution Error']
Next Objective: Analyze problem and propose initial plan


--------------------------------------------------------------------------------

[EVIDENCE] (Context: Reality check)

[EVIDENCE]
Turn 1 Logic:
[THOUGHTS]
*   The problem asks for the minimum number of multiplications by 2 to make a given subarray $A_l, \dots, A_r$ non-decreasing.
    *   Let $c_i$ be the number of multiplications on $A_i$. The greedy strategy for a range $[l, r]$ is:
        $c_l = 0$
        $c_i = \max(0, c_{i-1} + h_i)$ for $i > l$, where $h_i = \lceil \log_2(A_{i-1}/A_i) \rceil$.
    *   This recurrence can be rewritten using prefix sums of $h_i$. Let $S_i = \sum_{j=1}^i h_j$ (with $h_1=0$).
        Then $c_k = S_k - \min_{l \le j \le k} S_j$ for $k \in [l, r]$.
    *   The total number of operations $f(l, r)$ is $\sum_{k=l}^r (S_k - \min_{l \le j \le k} S_j) = (\sum_{k=l}^r S_k) - (\sum_{k=l}^r \min_{l \le j \le k} S_j)$.
    *   We can calculate $\sum_{k=l}^r S_k$ using prefix sums.
    *   To calculate $\sum_{k=l}^r \min_{l \le j \le k} S_j$, we use the fact that $\min_{l \le j \le k} S_j$ is a step function.
    *   We can precompute the first $j > i$ such that $S_j < S_i$ (let's call it $next\_smaller[i]$) using a stack.
    *   The step function can then be traversed using binary lifting (doubling).
    *   Complexity: $O((N+Q) \log N)$ time and $O(N \log N)$ space. This should pass within the time and memory limits for $N, Q = 2.5 \times 10^5$.
[PLAN]
1.  Read $N, Q$ and the sequence $A$.
2.  Calculate $h_i = \lceil \log_2(A_{i-1}/A_i) \rceil$ for $i=2, \dots, N$ and $h_1 = 0$.
3.  Compute prefix sums $S_i$ of $h_i$ and prefix sums $PS_i$ of $S_i$.
4.  Compute $next\_smaller[i]$, the first $j > i$ such that $S_j < S_i$, using a stack.
5.  Build binary lifting tables `up[K][N+2]` and `sum_up[K][N+2]`:
    *   `up[0][i] = next_smaller[i]`
    *   `sum_up[0][i] = (next_smaller[i] - i) * S_i`
    *   `up[k][i] = up[k-1][up[k-1][i]]`
    *   `sum_up[k][i] = sum_up[k-1][i] + sum_up[k-1][up[k-1][i]]`
6.  For each query $(l, r)$:
    *   Calculate $ans = PS_r - PS_{l-1} - \text{sum of step function}$.
    *   The sum of the step function is found by jumping through the `up` and `sum_up` tables as long as the jumps stay within $[l, r]$.
    *   Handle the final part of the range.
7.  Output all results.

[EXECUTION LOG]
Running sanitized code...
Execution timed out!

Turn 2 Logic:
[THOUGHTS]
The problem asks for the minimum number of multiplications by 2 to make a subarray $A_l, \dots, A_r$ non-decreasing.
The minimum operations for each element $A_i$ (where $l \le i \le r$) can be calculated greedily as $c_i = \max(0, c_{i-1} + h_i)$, with $c_l = 0$ and $h_i = \lceil \log_2(A_{i-1}/A_i) \rceil$.
This recurrence can be rewritten as $c_i = PS_i - \min_{l \le j \le i} PS_j$, where $PS_k$ is the prefix sum of $h_i$ (with $PS_l = 0$ effectively, but we can use global prefix sums).
The total operations $f(l, r)$ is $\sum_{i=l}^r PS_i - \sum_{i=l}^r \min_{l \le j \le i} PS_j$.
The first term is a simple prefix sum of $PS_i$. The second term is a sum of a step function, which can be calculated efficiently using binary lifting.
With $N, Q = 250,000$ and a 2.0s time limit, we need an efficient implementation. Python's `array.array` and tight loops for binary lifting table construction and query processing should work.
The formula $h_i = \lceil \log_2(A_{i-1}/A_i) \rceil$ needs careful implementation using bit operations for speed and correctness.
[PLAN]
1.  Read $N, Q$ and sequence $A$ using fast I/O.
2.  Calculate $h_i = \lceil \log_2(A_{i-1}/A_i) \rceil$ for $i=2, \dots, N$ and $h_1 = 0$.
3.  Compute prefix sums $PS_i$ of $h_i$ and prefix sums $PPS_i$ of $PS_i$.
4.  Compute $nxt[i]$, the first $j > i$ such that $PS_j < PS_i$, using a monotonic stack.
5.  Build binary lifting tables `up[k][i]` and `sum_up[k][i]` for $k \in [0, 18]$ and $i \in [1, N+1]$.
6.  For each query $(l, r)$:
    *   Calculate `total_sum = PPS[r] - PPS[l-1]`.
    *   Calculate `min_sum = sum of the step function` using the binary lifting tables.
    *   The answer is `total_sum - min_sum`.
7.  Print all results.

[EXECUTION LOG]
Running sanitized code...
Execution timed out!

Turn 3 Logic:
[THOUGHTS]
*   The problem asks for the minimum operations to make a given subarray $A_l, \dots, A_r$ non-decreasing, where an operation consists of multiplying an element by 2.
    *   Minimum operations for a subarray $X_1, \dots, X_M$:
        $c_1 = 0$
        $c_i = \max(0, c_{i-1} + h_i)$, where $h_i = \lceil \log_2(X_{i-1}/X_i) \rceil$.
    *   This is equivalent to $c_i = S_i - \min_{l \le j \le i} S_j$, where $S_i$ is the prefix sum of $h_i$.
    *   The total number of operations $f(l, r)$ is $\sum_{i=l}^r S_i - \sum_{i=l}^r \min_{l \le j \le i} S_j$.
    *   The second term, $G(l, r) = \sum_{i=l}^r \min_{l \le j \le i} S_j$, can be computed efficiently by observing the structure of $\min_{l \le j \le i} S_j$.
    *   For a fixed $l$, the sequence $M_i = \min_{l \le j \le i} S_j$ is a step function where the values change at indices $i_1=l, i_2=nxt[i_1], i_3=nxt[i_2], \dots$, where $nxt[k]$ is the first index $j > k$ such that $S_j < S_k$.
    *   This defines a tree where the parent of $i$ is $nxt[i]$. $G(l, r)$ is the sum along the path from $l$ to $r$.
    *   We can compute this sum using an offline DFS on the tree with a monotonic stack of ancestors to find the last node $i_m$ on the path such that $i_m \le r$.
    *   Complexity: $O(N + Q \log N)$ time and $O(N + Q)$ space. This should pass comfortably in Python.
[PLAN]
1.  Read $N, Q$ and the sequence $A$.
2.  Calculate $h_i$ for $i=2, \dots, N$ using bit manipulation to handle $\lceil \log_2(A_{i-1}/A_i) \rceil$ efficiently, and set $h_1 = 0$.
3.  Compute prefix sums $S_i = \sum_{j=1}^i h_j$ and prefix sums of $S_i$, $PS\_S_i = \sum_{j=1}^i S_j$.
4.  Compute $nxt[i]$ for each $i \in [1, N]$ as the first $j > i$ such that $S_j < S_i$. Set $nxt[i] = N + 1$ if no such $j$ exists.
5.  Define weights $W_u = S_u \cdot (nxt[u] - u)$ and compute `PathSum[u]`, the sum of weights from $u$ to the root $N + 1$ in the $nxt$ tree.
6.  Build an adjacency list for the tree.
7.  Read all queries and store them in `queries_at[l]` list.
8.  Perform an iterative DFS on the tree starting from $N+1$:
    *   Maintain the current path from the root.
    *   For each query $(l, r)$ at node $l$:
        *   Binary search on the path to find the highest ancestor $i_m$ of $l$ such that $i_m \le r$.
        *   $G(l, r) = (PathSum[l] - PathSum[nxt[i_m]]) - S_{i_m} \cdot (nxt[i_m] - 1 - r)$.
        *   Answer is $(PS\_S[r] - PS\_S[l-1]) - G(l, r)$.
9.  Print all results.

[EXECUTION LOG]
Running sanitized code...
Execution timed out!



--------------------------------------------------------------------------------

[TASK]
Based on the above:
1. ANALYZE the current State and Evidence.
2. DECIDE on the next logical step (Refine, Debug, Pivot, or Verify).
3. EXPLAIN your reasoning.
4. GENERATE the necessary Python code (Solution, Test Case, or Profiler Script).

[OUTPUT FORMAT]
Please provide your response in the following structured format:

<THOUGHTS>
(Analyze the evidence. Why did the last run fail? What is the new hypothesis?)
</THOUGHTS>

<PLAN>
(Step-by-step plan for this turn)
</PLAN>

<CODE>
(The actual Python code to be executed by the Executive)
</CODE>

<STATE_UPDATE>
(Proposed update to the State for the next turn)
- Current Approach: ...
- Status: (MUST be one of: "Active", "Debugging", "Finished")
- Next Objective: ...
</STATE_UPDATE>

[TERMINATION RULES]
- If you have fully verified the solution and it is correct, set Status to "Finished".
- If you are stuck or need to change approach, set Status to "Debugging" or "Active".
```
