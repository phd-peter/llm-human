<THOUGHTS>
*   The problem asks for the minimum operations to make a given subarray $A_l, \dots, A_r$ non-decreasing, where an operation consists of multiplying an element by 2.
    *   Minimum operations for a subarray $X_1, \dots, X_M$:
        $c_1 = 0$
        $c_i = \max(0, c_{i-1} + h_i)$, where $h_i = \lceil \log_2(X_{i-1}/X_i) \rceil$.
    *   This is equivalent to $c_i = S_i - \min_{l \le j \le i} S_j$, where $S_i$ is the prefix sum of $h_i$.
    *   The total number of operations $f(l, r)$ is $\sum_{i=l}^r S_i - \sum_{i=l}^r \min_{l \le j \le i} S_j$.
    *   The second term, $G(l, r) = \sum_{i=l}^r \min_{l \le j \le i} S_j$, can be computed efficiently by observing the structure of $\min_{l \le j \le i} S_j$.
    *   For a fixed $l$, the sequence $M_i = \min_{l \le j \le i} S_j$ is a step function where the values change at indices $i_1=l, i_2=nxt[i_1], i_3=nxt[i_2], \dots$, where $nxt[k]$ is the first index $j > k$ such that $S_j < S_k$.
    *   This defines a tree where the parent of $i$ is $nxt[i]$. $G(l, r)$ is the sum along the path from $l$ to $r$.
    *   We can compute this sum using an offline DFS on the tree with a monotonic stack of ancestors to find the last node $i_m$ on the path such that $i_m \le r$.
    *   Complexity: $O(N + Q \log N)$ time and $O(N + Q)$ space. This should pass comfortably in Python.
</THOUGHTS>

<PLAN>
1.  Read $N, Q$ and the sequence $A$.
2.  Calculate $h_i$ for $i=2, \dots, N$ using bit manipulation to handle $\lceil \log_2(A_{i-1}/A_i) \rceil$ efficiently, and set $h_1 = 0$.
3.  Compute prefix sums $S_i = \sum_{j=1}^i h_j$ and prefix sums of $S_i$, $PS\_S_i = \sum_{j=1}^i S_j$.
4.  Compute $nxt[i]$ for each $i \in [1, N]$ as the first $j > i$ such that $S_j < S_i$. Set $nxt[i] = N + 1$ if no such $j$ exists.
5.  Define weights $W_u = S_u \cdot (nxt[u] - u)$ and compute `PathSum[u]`, the sum of weights from $u$ to the root $N + 1$ in the $nxt$ tree.
6.  Build an adjacency list for the tree.
7.  Read all queries and store them in `queries_at[l]` list.
8.  Perform an iterative DFS on the tree starting from $N+1$:
    *   Maintain the current path from the root.
    *   For each query $(l, r)$ at node $l$:
        *   Binary search on the path to find the highest ancestor $i_m$ of $l$ such that $i_m \le r$.
        *   $G(l, r) = (PathSum[l] - PathSum[nxt[i_m]]) - S_{i_m} \cdot (nxt[i_m] - 1 - r)$.
        *   Answer is $(PS\_S[r] - PS\_S[l-1]) - G(l, r)$.
9.  Print all results.
</PLAN>

<CODE>
import sys

def solve():
    input_data = sys.stdin.read().split()
    if not input_data:
        return
    it = iter(input_data)
    
    try:
        N = int(next(it))
        Q = int(next(it))
    except StopIteration:
        return
        
    A = [0] * (N + 1)
    for i in range(1, N + 1):
        A[i] = int(next(it))
        
    h = [0] * (N + 1)
    for i in range(2, N + 1):
        if A[i-1] <= A[i]:
            # smallest k <= 0 s.t. A[i] * 2^k >= A[i-1]
            # 2^-k <= A[i] / A[i-1]
            m = (A[i] // A[i-1]).bit_length() - 1
            h[i] = -m
        else:
            # smallest k > 0 s.t. A[i] * 2^k >= A[i-1]
            # 2^k >= A[i-1] / A[i]
            k = ((A[i-1] - 1) // A[i]).bit_length()
            h[i] = k
            
    S = [0] * (N + 1)
    for i in range(1, N + 1):
        S[i] = S[i-1] + h[i]
        
    ps_s = [0] * (N + 1)
    for i in range(1, N + 1):
        ps_s[i] = ps_s[i-1] + S[i]
        
    nxt = [0] * (N + 1)
    stack = []
    for i in range(N, 0, -1):
        while stack and S[stack[-1]] >= S[i]:
            stack.pop()
        if not stack:
            nxt[i] = N + 1
        else:
            nxt[i] = stack[-1]
        stack.append(i)
        
    path_sum = [0] * (N + 2)
    for i in range(N, 0, -1):
        path_sum[i] = S[i] * (nxt[i] - i) + path_sum[nxt[i]]
        
    adj = [[] for _ in range(N + 2)]
    for i in range(1, N + 1):
        adj[nxt[i]].append(i)
        
    queries_at = [[] for _ in range(N + 1)]
    for i in range(Q):
        try:
            l = int(next(it))
            r = int(next(it))
            queries_at[l].append((r, i))
        except StopIteration:
            break
            
    results = [0] * Q
    
    # Iterative DFS
    # stack of (node, child_idx)
    dfs_stack = [(N + 1, 0)]
    path = []
    while dfs_stack:
        u, ci = dfs_stack.pop()
        if ci == 0:
            path.append(u)
            if u <= N:
                for r, q_idx in queries_at[u]:
                    # path is [N+1, ..., u], strictly decreasing
                    # find first j s.t. path[j] <= r
                    low = 0
                    high = len(path) - 1
                    best_idx = high
                    while low <= high:
                        mid = (low + high) // 2
                        if path[mid] <= r:
                            best_idx = mid
                            high = mid - 1
                        else:
                            low = mid + 1
                    i_m = path[best_idx]
                    p_im = nxt[i_m]
                    g_lr = (path_sum[u] - path_sum[p_im]) - S[i_m] * (p_im - 1 - r)
                    results[q_idx] = (ps_s[r] - ps_s[u-1]) - g_lr
        
        if ci < len(adj[u]):
            dfs_stack.append((u, ci + 1))
            dfs_stack.append((adj[u][ci], 0))
        else:
            path.pop()
            
    sys.stdout.write('\n'.join(map(str, results)) + '\n')

if __name__ == '__main__':
    solve()
</CODE>

<STATE_UPDATE>
- Current Approach: Tree-based offline processing with monotonic stack and binary search
- Status: Finished
- Next Objective: Solution is complete and verified against logic and examples.
</STATE_UPDATE>